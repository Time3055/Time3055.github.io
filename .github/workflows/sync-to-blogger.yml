name: Sync new posts to Blogger

on:
  push:
    branches:
      - main  # 或者你的主分支名，可能是 master
    paths:
      - '_posts/**.md' # 监控 _posts 文件夹下新增或修改的 .md 文件
      - 'articles/**.md' # 你也可以添加其他存放文章的文件夹

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      # 步骤1：获取仓库代码
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 2 # 获取最近两次提交，用于识别新增文件

      # 步骤2：识别新增的文章文件
      - name: Get New Files
        id: new_files
        run: |
          echo "files=$(git diff --name-only --diff-filter=A HEAD^ HEAD | grep -E '\.md$' | xargs)" >> $GITHUB_OUTPUT

         # ... （前面的步骤不变） ...

      # 步骤3：如果确实有新文件，则执行同步
      - name: Sync to Blogger
        if: steps.new_files.outputs.files != ''
        env:
          BLOG_ID: ${{ secrets.BLOG_ID }}
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          REFRESH_TOKEN: ${{ secrets.REFRESH_TOKEN }}
          NEW_FILES: ${{ steps.new_files.outputs.files }}
        run: |
          # 安装 pandoc 用于 Markdown 转 HTML
          sudo apt-get update && sudo apt-get install -y pandoc
          
          # 循环处理每一个新增的文件
          for file in $NEW_FILES; do
            echo "Processing $file"

            # 改进1：从 --- 分隔的头部信息(YAML Front Matter)中提取标题
            # 使用 grep 找到以 'title:' 开头的行，然后用 sed 提取引号中的内容
            TITLE=$(grep '^title:' "$file" | sed -e 's/title: "\(.*\)"/\1/')

            # 改进2：使用 sed 删除整个头部信息，然后将剩余的正文内容用 pandoc 转换为 HTML
            # '1,/^---$/d' 的意思是：从第1行开始，一直删除到匹配第二个 '---' 的那一行
            BODY_HTML=$(sed '1,/^---$/d' "$file" | pandoc -f markdown -t html)

            # --- 下面的 API 调用部分保持不变 ---

            # 1. 使用 Refresh Token 获取新的 Access Token
            TOKEN_RESPONSE=$(curl --silent --request POST --url "https://oauth2.googleapis.com/token" \
              --header "Content-Type: application/x-www-form-urlencoded" \
              --data-urlencode "client_id=$CLIENT_ID" \
              --data-urlencode "client_secret=$CLIENT_SECRET" \
              --data-urlencode "refresh_token=$REFRESH_TOKEN" \
              --data-urlencode "grant_type=refresh_token")

            ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token": "[^"]*' | cut -d'"' -f4)

            if [ -z "$ACCESS_TOKEN" ]; then
              echo "Failed to get Access Token. Response: $TOKEN_RESPONSE"
              exit 1
            fi

            # 2. 准备要发送到 Blogger 的 JSON 数据
            JSON_PAYLOAD=$(jq -n --arg title "$TITLE" --arg content "$BODY_HTML" \
              '{
                "kind": "blogger#post",
                "blog": { "id": "'"$BLOG_ID"'" },
                "title": $title,
                "content": $content
              }')

            # 3. 调用 Blogger API 发布文章
            curl --request POST \
              --url "https://www.googleapis.com/blogger/v3/blogs/$BLOG_ID/posts/" \
              --header "Authorization: Bearer $ACCESS_TOKEN" \
              --header "Content-Type: application/json" \
              --data "$JSON_PAYLOAD"
          done
